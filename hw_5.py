# -*- coding: utf-8 -*-
"""HW_5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W-yxE53BaDTeuoObcodHQMOu7iqgPqGo
"""

!pip install ISLP

import numpy as np
from matplotlib.pyplot import subplots, cm
import sklearn.model_selection as skm
from ISLP import load_data, confusion_table

from sklearn.svm import SVC
from ISLP.svm import plot as plot_svm
from sklearn.metrics import RocCurveDisplay

roc_curve = RocCurveDisplay.from_estimator

"""# Q5. Support Vector Machine

##(a)
"""

Auto = load_data('Auto')
Auto

mpg_median = np.median(Auto['mpg'])
mpg_median

Auto['mpg_m'] = (Auto['mpg'] > mpg_median).astype(int)

quantities = ['cylinders', 'displacement', 'horsepower', 'weight', 'acceleration', 'year', 'origin']
Auto[quantities] = Auto[quantities].astype(np.float64)

f = 'mpg_m ~ cylinders + displacement + horsepower + weight + acceleration + year + C(origin)'

y = Auto['mpg_m']

X = Auto.drop(['mpg', 'mpg_m', 'name'], axis=1)
X

import torch
device = 'cuda' if torch.cuda.is_available() else 'cpu'

from sklearn.model_selection import cross_val_score

costs = np.logspace(-5, 2, 20)
scores = []
for i in costs:
  model = SVC(C=i, kernel = 'linear')
  score = np.mean(cross_val_score(model, X, y, cv=5))
  score_tensor = torch.tensor(score, dtype=torch.float64).to(device)
  score_tensor_cpu = score_tensor.cpu()
  scores.append([i, score_tensor_cpu])

import pandas as pd

result_array = np.array(scores)
columns = ['cost', 'score']
result = pd.DataFrame(data = result_array, columns=columns)
display(result)

import matplotlib.pyplot as plt
import seaborn as sns

result['log(cost)'] = np.log(result['cost'])
plt.figure()
sns.lineplot(x='log(cost)', y='score', data=result)

max(result['score'])

max_score_cost = 0.000695
svm = SVC(C=max_score_cost, kernel='linear').fit(X,y)
fig, ax = subplots(figsize=(8,8))
plot_svm(X, y, svm, ax=ax)

"""##(b)

"""

import numpy as np
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import GridSearchCV

tune_param = [{'C': [0.01, 0.1, 1, 10], 'degree': [2, 3, 4]}]
rbf_grid   = GridSearchCV(SVC(kernel='poly'), tune_param, cv=5, scoring='accuracy', n_jobs=-1)
rbf_grid.fit(X, y)
best_svmp  = rbf_grid.best_estimator_ 
print('best cost for SVM poly %s' %rbf_grid.best_params_) 

tune_param = [{'C': [0.01, 0.1, 1, 10], 'gamma': [0.5, 1, 2]}]
rbf_grid   = GridSearchCV(SVC(kernel='rbf'), tune_param, cv=5, scoring='accuracy', n_jobs=-1)
rbf_grid.fit(X, y)
best_svmr  = rbf_grid.best_estimator_ 
print('best cost for SVM poly %s' %rbf_grid.best_params_) 

tune_param = [{'C': [0.01, 0.1, 1, 10],'gamma': [0.5, 1, 2], 'degree': [2, 3, 4]} ]
rbf_grid   = GridSearchCV(SVC(kernel='rbf'), tune_param, cv=5, scoring='accuracy', n_jobs=-1)
rbf_grid.fit(X, y)
best_svmr  = rbf_grid.best_estimator_ 
print('best cost for SVM rbf %s' %rbf_grid.best_params_) 

tune_param = [{'C': [0.01, 0.1, 1, 10],'gamma': [0.5, 1, 2], 'degree': [2, 3, 4]} ]
rbf_grid   = GridSearchCV(SVC(kernel='poly'), tune_param, cv=5, scoring='accuracy', n_jobs=-1)
rbf_grid.fit(X, y)
best_svmr  = rbf_grid.best_estimator_ 
print('best cost for SVM poly %s' %rbf_grid.best_params_) 

"""# Q6. Survival analysis on brain tumor data

## (a)
"""

from ISLP import load_data
BrainCancer = load_data('BrainCancer')
BrainCancer

from matplotlib.pyplot import subplots
import numpy as np
import pandas as pd
from ISLP.models import ModelSpec as MS
from lifelines import KaplanMeierFitter, CoxPHFitter
from lifelines.statistics import logrank_test, multivariate_logrank_test
from ISLP.survival import sim_time
import matplotlib.pyplot as plt

fig, ax = subplots(figsize=(8,8))
km = KaplanMeierFitter()
km_brain = km.fit(BrainCancer['time'], BrainCancer['status'])
km_brain.plot_survival_function(ax=ax, ci_show=True, ci_alpha=0.33)

ax.set_title('Kaplan-Meier Survival Curve with +=1 SE Bands')
ax.set_xlabel('Time')
ax.set_ylabel('Survival Probability')
plt.legend(loc='lower left')

plt.show()

"""## (b)"""

kmf = KaplanMeierFitter()
kmf.fit(BrainCancer['time'], BrainCancer['status'])
kmf.plot_survival_function(ci_show=True, ci_alpha=0.33, color='steelblue')

B = 200
n = len(BrainCancer)
times = np.unique(BrainCancer['time'])
bootstrap_survival_curves = []

for _ in range(B):
  bootstrap_sample = BrainCancer.sample(n, replace = True)
  kmf_bootstrap = KaplanMeierFitter()
  kmf_bootstrap.fit(durations = bootstrap_sample['time'], event_observed=bootstrap_sample['status'])
  bootstrap_survival_curves.append(kmf_bootstrap.survival_function_at_times(times))

bootstrap_survival_curves = pd.concat(bootstrap_survival_curves, axis=1)
se = np.std(bootstrap_survival_curves, axis=1)

plt.plot(kmf.timeline, kmf.survival_function_, label='Original', color='steelblue')
plt.plot(kmf.timeline[1:], kmf.survival_function_.drop(kmf.survival_function_.index[0]).values - se.values, linestyle='dashed', color='red', label='Lower 67% CI')
plt.plot(kmf.timeline[1:], kmf.survival_function_.drop(kmf.survival_function_.index[0]).values + se.values, linestyle='dashed', color='red', label='Upper 67% CI')
plt.xlabel('Time')
plt.ylabel('Survival Probability')
plt.show()

"""##(C)

"""

import pandas as pd
from lifelines import CoxPHFitter

predictors = pd.get_dummies(BrainCancer[['sex', 'diagnosis','loc', 'stereo']], drop_first=True)
predictors[['ki', 'gtv']] = BrainCancer[['ki', 'gtv']]
cox_data = pd.concat([predictors, BrainCancer['time'], BrainCancer['status']], axis=1)

model = CoxPHFitter()
model.fit(cox_data, duration_col='time', event_col='status')
print(model.summary)

"""##(d)

"""

import pandas as pd
from lifelines import KaplanMeierFitter
import matplotlib.pyplot as plt

predictors = pd.get_dummies(BrainCancer[['sex', 'diagnosis', 'loc', 'stereo']], drop_first=True)
predictors[['ki', 'gtv']] = BrainCancer[['ki', 'gtv']]

cox_data = pd.concat([predictors, BrainCancer['time'], BrainCancer['status']], axis=1)

cph = CoxPHFitter()
cph.fit(cox_data, duration_col='time', event_col='status')
cox_data.loc[cox_data['ki'] == 40, 'ki'] = 60
fig, ax = plt.subplots()

ki_values = [60, 70, 80, 90, 100]
kmf = KaplanMeierFitter()
for ki_value in ki_values:
  subset_data = cox_data[cox_data['ki'] == ki_value]
  kmf.fit(durations=subset_data['time'], event_observed=subset_data['status'], label=f'ki={ki_value}')
  kmf.plot_survival_function(ax=ax, ci_show=False)

plt.xlabel('Time')
plt.ylabel('Survival Probability')
legend_labels = [f'ki={ki}' for ki in ki_values]
ax.legend(legend_labels, loc='best')
plt.show()
